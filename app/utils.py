# Some utility functions

from future import standard_library
standard_library.install_aliases()
from subprocess import Popen, PIPE, call
import traceback
import sys
import errno
import logging
import os
import time
import urllib.parse

log = logging.getLogger('pipeline.' + __name__)

# Dictionary defining the analysis mode for each languages
# tt = TreeTagger
# fl = Freeling  # FreeLing
TOOL_DICT = {
    "sv": "sv",
    "sv-dev": "sv-dev",
    "sv-1800": "sv-1800",
    # "as": "fl",  # FreeLing
    "ca": "fl",  # FreeLing
    # "cy": "fl",  # FreeLing
    "en": "fl",  # FreeLing
    "de": "fl",  # FreeLing
    "es": "fl",  # FreeLing
    "fr": "fl",  # FreeLing
    "gl": "fl",  # FreeLing
    "it": "fl",  # FreeLing
    "no": "fl",  # FreeLing
    "pt": "fl",  # FreeLing
    "ru": "fl",  # FreeLing
    "sl": "fl",  # FreeLing
    "bg": "tt",
    "et": "tt",
    "fi": "tt",
    "la": "tt",
    "nl": "tt",
    "pl": "tt",
    "ro": "tt",
    "sk": "tt",
}


# Error messages for different error types
ERROR_MSG = {
    "parsing_error": "Not all input could be parsed. XML might be invalid.",
    "missing_file": "Not all files could be processed. At least one file is missing from the result.",
    "no_result": "No result found. Something went wrong in the corpus pipeline.",
    "empty_input": "No input was found.",
    "no_files": "No files provided for upload.",
    "make_error": "Error occurred while running make."
}

UTF8 = "UTF-8"


def pretty_epoch_time(t):
    """Print an epoch time nicely."""
    dateformat = "%Y-%m-%d %H:%M:%S"
    return time.strftime(dateformat, time.localtime(t))


def query(environ, key, default):
    """
    Cache the environment dictionary, and return the value of a given key,
    or the default value if it does not exist.
    """
    if 'query_dict' not in environ:
        environ['query_dict'] = urllib.parse.parse_qs(environ.get('QUERY_STRING', ""))
    return environ['query_dict'].get(key, [default])[0]


def text(environ):
    """Either get the POST content, or get content from the "text" query variable."""
    try:
        length = int(environ.get('CONTENT_LENGTH', '0'))
    except ValueError:
        length = 0

    if length != 0:
        return environ['wsgi.input'].read(length)
    else:
        return query(environ, 'text', '')


def is_sha1(instring):
    """Check if instring is sha1 hash."""
    if instring.endswith("-f"):
        instring = instring[:-2]
    if len(instring) != 40:
        return False
    try:
        int(instring, 16)
    except ValueError:
        return False
    return True


def get_build_directories(builds_dir):
    """Get a list of the build directories from the builds dir."""
    dirlist = os.walk(builds_dir).__next__()[1]
    return [d for d in dirlist if is_sha1(d)]


def make_hash(*texts):
    """
    The text is hashed together with its makefile because the built corpus
    will look different on many settings. For example, if word annotations
    are taken from the corpus or generated by our tools.
    """
    import hashlib
    return hashlib.sha1("".join(texts).encode("UTF-8")).hexdigest()


def make(settings):
    """
    Calls make with a given settings (a dict containing JSON valid by the schema)
    """
    log.info("Calling /usr/bin/make %s" % ' '.join(settings))
    # return subprocess.check_output(['/usr/bin/make'] + settings)
    return Popen(['/usr/bin/make'] + settings,
                 shell=False, close_fds=False,
                 stdin=None, stdout=PIPE, stderr=PIPE)


def mkdir(d):
    """Make directory d."""
    try:
        os.makedirs(d, mode=0o777)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise
    call(['chmod', '777', d, '-v'])


def rmdir(d):
    """Remove directory d."""
    call(['rm', '-rf', d])


def make_trace():
    """ Return a traceback."""
    return "".join(traceback.format_exception(*sys.exc_info()))
