# Some utility functions

from subprocess import Popen, PIPE, call
# import subprocess

import errno
import logging
import os
import time
import urlparse

log = logging.getLogger('pipeline.' + __name__)

# Dictionary defining the analysis mode for each languages
# tt = TreeTagger, fl = Freeling
TOOL_DICT = {
    "sv": "sv",
    "sv-dev": "sv-dev",
    "sv-1800": "sv-1800",
    "as": "fl",
    "ca": "fl",
    "cy": "fl",
    "en": "fl",
    "es": "fl",
    "fr": "fl",
    "gl": "fl",
    "it": "fl",
    "pt": "fl",
    "ru": "fl",
    "sl": "fl",
    "bg": "tt",
    "de": "tt",
    "la": "tt",
    "sk": "tt",
    "et": "tt",
    "fi": "tt"
    "nl": "tt",
    "pl": "tt",
}


# Error messages for different error types
ERROR_MSG = {
    "parsing_error": "Not all input could be parsed. XML might be invalid.",
    "missing_file": "Not all files could be processed. At least one file is missing from the result.",
    "no_result": "No result found. Something went wrong in the corpus pipeline.",
    "empty_input": "No input was found."
}


def pretty_epoch_time(t):
    """Print an epoch time nicely."""
    dateformat = "%Y-%m-%d %H:%M:%S"
    return time.strftime(dateformat, time.localtime(t))


def query(environ, key, default):
    """
    Cache the environment dictionary, and return the value of a given key,
    or the default value if it does not exist.
    """
    if 'query_dict' not in environ:
        environ['query_dict'] = urlparse.parse_qs(environ.get('QUERY_STRING', ""))
    return environ['query_dict'].get(key, [default])[0]


def text(environ):
    """Either get the POST content, or get content from the "text" query variable."""
    try:
        length = int(environ.get('CONTENT_LENGTH', '0'))
    except ValueError:
        length = 0

    if length != 0:
        return environ['wsgi.input'].read(length)
    else:
        return query(environ, 'text', '')


def make_hash(*texts):
    """
    The text is hashed together with its makefile because the built corpus
    will look different on many settings. For example, if word annotations
    are taken from the corpus or generated by our tools.
    """
    import hashlib
    return hashlib.sha1("".join(texts)).hexdigest()


def make(settings):
    """
    Calls make with a given settings (a dict containing JSON valid by the schema)
    """
    log.info("Calling /usr/bin/make %s" % ' '.join(settings))
    # return subprocess.check_output(['/usr/bin/make'] + settings)
    return Popen(['/usr/bin/make'] + settings,
                 shell=False, close_fds=False,
                 stdin=None, stdout=PIPE, stderr=PIPE)


def mkdir(d):
    """Make directory d."""
    try:
        os.makedirs(d, mode=0777)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise
    call(['chmod', '777', d, '-v'])


def rmdir(d):
    """Remove directory d."""
    call(['rm', '-rf', d])
